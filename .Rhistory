unl<- data.frame(Reduce(rbind, ys5.s))
x<- t(unl[,2])
y<- t(unl[,3])
v = rbind(x,y)
mid<- ceiling(length(x)/2)
x_center = x[mid]
y_center = y[mid]
#create a matrix which will be used later in calculations
center = v
center[1,]<- x_center
center[2,]<- y_center
deg<- 10 #define the amount of rotation required (degrees) #Keep in mind the initial trasects are vertically orientated #
theta = (deg * pi)/180      # express in radians
R = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow=2)
# do the rotation...
s = v - center    # shift points in the plane so that the center of rotation is at the origin
so = R%*%s           # apply the rotation about the origin
vo = so + center   # shift again so the origin goes back to the desired center of rotation
# pick out the vectors of rotated x- and y-data
x_rotated = vo[1,]
y_rotated = vo[2,]
#make a plot (not a very nice one but enough to get the idea)
plot(x, y, type="l", col="red")
lines(x_rotated, y_rotated, col="blue")
# combine original transects with rotated transects
unl<- cbind(unl, t(vo))
names(unl)[4:5]<- c("new_X", "new_Y")
#split by id
ys6.s<- split(unl, unl$id)
#Save all transects to 1 shapefile
transectDist<- matrix(NA, nrow=length(ys6.s), ncol=2) # matrix to put transect distances
l.list <- vector("list", length(ys6.s))
for (i in seq_along(l.list)) {
l.list[[i]] <- Lines(list(Line(coordinates(ys6.s[[i]][,4:5]))), ID= paste("transect",as.character(i),sep="_" ))
transectDist[i,1]<- as.matrix(ys6.s[[i]][1,1])}
xxx<- SpatialLines(l.list)
transectDist[,2]<- SpatialLinesLengths(xxx)
transectDist<- as.data.frame(transectDist)
names(transectDist)<- c("transect", "distance")
bound1.t
testXX<- crop(xxx,bound1.t)
xxx
plot(bound1.t)
plot(xxx,add=# Wed Nov 07 00:43:08 2018 ------------------------------
)
plot(bound1.t)
plot(xxx,add=T)
crs(xxx)<- crs(bound1.t)
testXX<- crop(xxx,bound1.t)
plot(bound1.t)
plot(testXX,add=T)
testXX
#polygons
bound1<- readOGR("Z:/Dropbox/2018/soil3009/data/muddles/filedBound2018_soil3009.shp") #read in polygon
library(raster);library(maptools);library(rgdal);library(rgeos)
#polygons
bound1<- readOGR("Z:/Dropbox/2018/soil3009/data/muddles/filedBound2018_soil3009.shp") #read in polygon
plot(bound1)
bound1
#CRS and redefine
crs(bound1) <- "+init=epsg:32756"
#bound1.t <- spTransform(bound1, CRS("+init=epsg:32755"))
bound1.t <- bound1
#extent
bound1.extent<-as.matrix(extent(bound1.t)) # Get the extent of the polygon
bound1.extent
#extent
bound1.extent<-as.matrix(extent(bound1.t)) # Get the extent of the polygon
bound1.extent[1,2]- bound1.extent[1,2]
bound1.extent[1,2]- bound1.extent[1,1]
bound1.extent[2,2]- bound1.extent[2,1]
#Buffer out the extent
# make a sqaure buffer
distX<- bound1.extent[1,2]- bound1.extent[1,1]
distY<- bound1.extent[2,2]- bound1.extent[2,1]
c(distX, distY)
library(raster)
?crop
files<- list.files(path = "Z:/Dropbox/2018/cubby/vesper/krigOut/",'kriged', full.names = T)
files
s1<- stack()
for (i in 1:length(files)){
dat<- read.table(files[i], header = T, sep="")
r1<- rasterFromXYZ(dat[,2:4])
nm1<- as.character(files[i])
nm2<- substr(nm1, 1,nchar(nm1)-4)
nm3<- substr(nm2, 51,nchar(nm2))
names(r1)<- nm3
s1<- stack(s1,r1)
}
s1
i=1
dat<- read.table(files[i], header = T, sep="")
dat
r1<- rasterFromXYZ(dat[,2:4])
r1
nm1<- as.character(files[i])
nm1
nm2<- substr(nm1, 1,nchar(nm1)-4)
nm2
substr(nm2, 35,nchar(nm2))
substr(nm2, 38,nchar(nm2))
s1<- stack()
for (i in 1:length(files)){
dat<- read.table(files[i], header = T, sep="")
r1<- rasterFromXYZ(dat[,2:4])
nm1<- as.character(files[i])
nm2<- substr(nm1, 1,nchar(nm1)-4)
nm3<- substr(nm2, 38,nchar(nm2))
names(r1)<- nm3
s1<- stack(s1,r1)
}
s1
crs(s1)<- "+init=epsg:3112"
#clipping boundary
bound1<- readOGR("Z:/Dropbox/FieldClip2/FieldClipV2.shp")
## read in kriged map and re-scale to 20m
library(raster);library(sp);library(rgdal)
#clipping boundary
bound1<- readOGR("Z:/Dropbox/FieldClip2/FieldClipV2.shp")
crs(bound1)
bound1 <- spTransform(bound1, CRS("+init=epsg:3112"))  # Easting and Northing
plot(s1[[2]])
plot(bound1,add=T)
#clip raster according to boundary
cr1 <- crop(s1, extent(bound1), snap="in")     #crop rasters to extent of boundary
fr1 <- rasterize(bound1, cr1)   #rasterise the polygon
lr1 <- mask(x=cr1, mask=fr1) #use the mask
plot(lr1[[1]])
lr1
#re-project
pl.grid20 <- projectRaster(lr1, crs=crs(lr1),method="bilinear", res=20)
pl.grid20
plot(pl.grid20[[1]])
nlayers(pl.grid20)
for (i in 1:11){
r1<- pl.grid20[[i]]
nm1<- names(r1)
nm2<- paste("Z:/Dropbox/Clarkes DualEM Survey/processed/krigOuts/fieldBound2", nm1, ".tif", sep="")
writeRaster(r1, filename = nm2,format = "GTiff", overwrite = TRUE)}
nlayers(pl.grid20)
for (i in 1:11){
r1<- pl.grid20[[i]]
nm1<- names(r1)
nm2<- paste("Z:/Dropbox/Clarkes DualEM Survey/processed/krigOuts/fieldBound2/", nm1, ".tif", sep="")
writeRaster(r1, filename = nm2,format = "GTiff", overwrite = TRUE)}
#clip raster according to boundary
cr1 <- crop(s1, extent(bound1), snap="out")     #crop rasters to extent of boundary
fr1 <- rasterize(bound1, cr1)   #rasterise the polygon
lr1 <- mask(x=cr1, mask=fr1) #use the mask
plot(lr1[[1]])
#re-project
pl.grid20 <- projectRaster(lr1, crs=crs(lr1),method="bilinear", res=20)
pl.grid20
plot(pl.grid20[[1]])
nlayers(pl.grid20)
for (i in 1:11){
r1<- pl.grid20[[i]]
nm1<- names(r1)
nm2<- paste("Z:/Dropbox/Clarkes DualEM Survey/processed/krigOuts/fieldBound2/", nm1, ".tif", sep="")
writeRaster(r1, filename = nm2,format = "GTiff", overwrite = TRUE)}
nlayers(pl.grid20)
for (i in 1:11){
r1<- pl.grid20[[i]]
nm1<- names(r1)
nm2<- paste("Z:/Dropbox/Clarkes DualEM Survey/processed/krigOuts/fieldBound2/", nm1, ".tif", sep="")
writeRaster(r1, filename = nm2,format = "GTiff", overwrite = TRUE)}
crop
?crop
?mask
fr1
plot(fr1)
#clip raster according to boundary
mr1<- raster("Z:/Dropbox/Clarkes DualEM Survey/20m_buffered_covariates/HCP160_buffered.tif")
mr1
lr1 <- mask(x=cr1, mask=mr1) #use the mask
cr1 <- crop(s1, extent(bound1), snap="out")     #crop rasters to extent of boundary
fr1 <- rasterize(bound1, cr1)   #rasterise the polygon
lr1 <- mask(x=cr1, mask=fr1) #use the mask
plot(lr1[[1]])
#re-project
pl.grid20 <- projectRaster(lr1, crs=crs(lr1),method="bilinear", res=20)
pl.grid20
plot(pl.grid20[[1]])
mr1<- raster("Z:/Dropbox/Clarkes DualEM Survey/20m_buffered_covariates/HCP160_buffered.tif")
lr1 <- mask(x=pl.grid20, mask=mr1) #use the mask
plot(lr1[[1]])
lr1
#tabulate
## Below is just combining all the raster data into a single data frame
tempD <- data.frame(cellNos = seq(1:ncell(pl.grid20)))
vals <- as.data.frame(getValues(pl.grid20))
nlayers(lr1)
for (i in 1:11){
r1<- lr1[[i]]
nm1<- names(r1)
nm2<- paste("Z:/Dropbox/Clarkes DualEM Survey/processed/krigOuts/fieldBound2/", nm1, ".tif", sep="")
writeRaster(r1, filename = nm2,format = "GTiff", overwrite = TRUE)}
#base raster
mr1<- raster("Z:/Dropbox/Clarkes DualEM Survey/20m_buffered_covariates/HCP160_buffered.tif")
# Get raster values at pss points
# thin out pss points per unique pixel
library(raster);library(sp);library(rgdal)
##pss points
dat<- readOGR("Z:/Dropbox/FieldClip2/TotalOnly.shp")
crs(mr1)
crs(dat)
dat<- spTransform(dat,CRSobj = crs(mr1))
plot(mr1)
plot(dat,add=T)
?extract
#extract raster values at points
dat.extract<- extract(mr1, dat,sp=T, cellnumbers=T)
dat.extract
dat.extract<- as.data.frame(dat.extract)
dat.extract<- dat.extract[complete.cases(dat.extract),]
str(dat.extract)
str(dat.extract)
# Get raster values at pss points
# thin out pss points per unique pixel
# Get raster values at pss points
# thin out pss points per unique pixel
library(raster);library(sp);library(rgdal)
#base raster
mr1<- raster("Z:/Dropbox/Clarkes DualEM Survey/20m_buffered_covariates/HCP160_buffered.tif")
crs(mr1)
##pss points
dat<- readOGR("Z:/Dropbox/FieldClip2/TotalOnly.shp")
crs(dat)
dat<- spTransform(dat,CRSobj = crs(mr1))
#extract raster values at points
dat.extract<- extract(mr1, dat,sp=T, cellnumbers=T)
dat.extract<- as.data.frame(dat.extract)
dat.extract<- dat.extract[complete.cases(dat.extract),]
str(dat)
str(dat.extract)
unique(dat.extract$cells)
uniqcell<- unique(dat.extract$cells)
str(dat.extract)
rdat<- dat.extract[,c(7,8,5)]
head(rdat)
names(rdat)
names(rdat)<- c("X", "Y", "cell")
uniqcell<- unique(rdat$cells)
j=1
sel<- uniqcell[j]
sel
uniqcell[1:100]
uniqcell<- unique(rdat$cells)
uniqcell<- unique(rdat$cell)
sel<- uniqcell[j]
sel
rdat[rdat$cell == sel,]
rr<- rdat[rdat$cell == sel,]
rr<- rdat[rdat$cell == sel,]
sample(1:nrow(rr), 1)
nrow(rr)
sample(1:nrow(rr), 1)
for (j in 1:length(uniqcell)){
sel<- uniqcell[j]
rr<- rdat[rdat$cell == sel,]
sample(1:nrow(rr), 1)
}
sample(1:nrow(rr), 1)
findat<- rdat[0,]
finaldat
findat
rsel<- sample(1:nrow(rr), 1)
rr[rsel,]
findat[j,]<- rr[rsel,]
findat
findat[1,]
j
j=1
findat<- rdat[0,]
sel<- uniqcell[j]
rr<- rdat[rdat$cell == sel,]
rsel<- sample(1:nrow(rr), 1)
findat[j,]<- rr[rsel,]
findat
findat<- rdat[0,]
for (j in 1:length(uniqcell)){
sel<- uniqcell[j]
rr<- rdat[rdat$cell == sel,]
rsel<- sample(1:nrow(rr), 1)
findat[j,]<- rr[rsel,]}
str(findat)
##write table to files
write.table(findat, "Z:/Dropbox/Clarkes DualEM Survey/processed/possibleSamps_all.txt", sep = ",", row.names = F, col.names = T)
coordinates(findat)<- ~ X + Y
crs(findat)
crs(findat)<- crs(mr1)
plot(mr1)
plot(findat,add=T)
writeOGR(findat, "Z:/Dropbox/Clarkes DualEM Survey/processed/", "possibleSamps_all", "ESRI Shapefile")
writeOGR(findat, "Z:/Dropbox/Clarkes DualEM Survey/processed", "possibleSamps_all", "ESRI Shapefile")
library(raster);library(rgdal);library(sp)
dat<- readOGR("Z:/Dropbox/FieldClip2/TotalOnly.shp")
str(dat)
crs(dat)
#raster
r1<- raster("Z:/Dropbox/Clarkes DualEM Survey/processed/krigOuts/")
#raster
r1<- raster("Z:/Dropbox/Clarkes DualEM Survey/processed/krigOuts/kriged_elevation.tif")
crs(r1)
#transform point data
dat<- spTransform(dat,CRSobj = crs(r1))
plot(r1)
plot(dat,add=T)
dat<- as.data.frame(dat)
str(dat)
dat<- dat[,c(5,6,4)]
names(dat)<- c("X", "Y", "adjustedTC")
write.table(dat, "Z:/Dropbox/Clarkes DualEM Survey/processed/gamma/adjustedTC.txt", sep = ",", row.names = F, col.names = T)
?qnorm
qnorm(0.95)
qnorm(0.90)
coordinates(dat)<- X + Y
coordinates(dat)<- ~ X + Y
dat2<- remove.duplicates(dat)
nrow(dat2)
nrow(dat)
dat<- as.data.frame(dat2)
str(dat)
write.table(dat, "Z:/Dropbox/Clarkes DualEM Survey/processed/gamma/adjustedTC.txt", sep = ",", row.names = F, col.names = T)
install.packages("clhs")
library(clhs)
?clhs
setwd("Z:/Dropbox/2019/rmuddles/clhs_addtion")
# data frame of covariate data
tempD<- readRDS("tempD.rds")
# Libraries
library(raster);library(sp); library(rgdal); library(clhs)
#rasterise covariate data
s1<- stack()
for (i in 4:ncol(tempD)){
r1<- rasterFromXYZ(tempD[,c(1,2,i)])
names(r1)<- names(tempD[i])
s1<- stack(s1,r1)
}
s1
# Required R Packages
library(sp)
library(raster)
library(rgdal)
#data
setwd("Z:/Dropbox/2019/rmuddles/clhs_addtion")
tempD<- readRDS("tempD.rds")
dat<- read.table("HunterValley_SiteObsAll.txt", header = T,sep = ",")
#Point data (the exisitng sample point data)
dat<- read.table("HunterValley_SiteObsAll.txt", header = T,sep = ",")  # existing soil point data
#extract covariate data at points
coordinates(dat)<- ~ X +Y
DSM_data<- extract(s1,dat, sp= 1, method = "simple") #extract
dat<- as.data.frame(DSM_data)
dat<- dat[complete.cases(dat),]
str(dat)
## Spatial points
coordinates(dat) <- ~X + Y
## Coordinate reference systems
proj4string(dat) <- CRS("+init=epsg:32756")
## Coordinate transformation
dat <- spTransform(dat, CRS("+init=epsg:4326"))
library(leaflet)
library(magrittr)
##
## #with forward pipe operator
m2<- leaflet() %>%
addTiles() %>%
addMarkers(data = dat)
m2
str(dat)
## Fiddling around with the markers
## Populate pop-ups
my_pops <- paste0(
"<strong>ID: </strong>",
dat$id,
'<br>
<strong> Year sampled: </strong>',
dat$Year,
'<br>
<strong> Sampled by: </strong>',
dat$Operator)
my_pops
##  Create interactive map
leaflet() %>%
addProviderTiles("Esri.WorldImagery") %>%
addMarkers(data = dat, popup = my_pops)
##  Create interactive map
m2<- leaflet() %>%
addProviderTiles("Esri.WorldImagery") %>%
addMarkers(data = dat, popup = my_pops)
#size appropriately
m2$height<- 500
m2$width<- 700
### Save the HTML widget
saveWidget(m2, file="C:/rdev/site_source/_includes/htmlwidgets/clhs1.html")
library(htmlwidgets)
### Save the HTML widget
saveWidget(m2, file="C:/rdev/site_source/_includes/htmlwidgets/clhs1.html")
### Save the HTML widget
saveWidget(m2, file="Z:/rdev/site_source/_includes/htmlwidgets/clhs1.html")
## clhs sampling with fixed obs and add an extra 100 sites
library(clhs)
setwd("Z:/Dropbox/2019/rmuddles/clhs_addtion")
# data frame of covariate data
tempD<- readRDS("tempD.rds")
# Libraries
library(raster);library(sp); library(rgdal); library(clhs)
#rasterise covariate data
s1<- stack()
for (i in 4:ncol(tempD)){
r1<- rasterFromXYZ(tempD[,c(1,2,i)])
names(r1)<- names(tempD[i])
s1<- stack(s1,r1)
}
s1
#tabulate (as i want the cell number)
tempD <- data.frame(cellNos = seq(1:ncell(s1)))
vals <- as.data.frame(getValues(s1))
tempD<- cbind(tempD, vals)
tempD <- tempD[complete.cases(tempD), ]
cellNos <- c(tempD$cellNos)
gXY <- data.frame(xyFromCell(s1, cellNos, spatial = FALSE))
tempD<- cbind(gXY, tempD)
str(tempD)
#rasterise again
s1<- stack()
for (i in 3:ncol(tempD)){
r1<- rasterFromXYZ(tempD[,c(1,2,i)])
names(r1)<- names(tempD[i])
s1<- stack(s1,r1)
}
s1
#Point data (the exisitng sample point data)
dat<- read.table("HunterValley_SiteObsAll.txt", header = T,sep = ",")  # existing soil point data
#extract covariate data at points
coordinates(dat)<- ~ X +Y
DSM_data<- extract(s1,dat, sp= 1, method = "simple") #extract
dat<- as.data.frame(DSM_data)
dat<- dat[complete.cases(dat),]
str(dat)
#remove the grid points where there is point data
tempD<- tempD[-which(tempD$cellNos %in% dat$cellNos),]
str(tempD)
setwd("Z:/Dropbox/2019/rmuddles/clhs_addtion")
# data frame of covariate data
tempD<- readRDS("tempD.rds")
# Libraries
library(raster);library(sp); library(rgdal); library(clhs)
#rasterise covariate data
s1<- stack()
for (i in 4:ncol(tempD)){
r1<- rasterFromXYZ(tempD[,c(1,2,i)])
names(r1)<- names(tempD[i])
s1<- stack(s1,r1)
}
s1
#tabulate (as i want the cell number)
tempD <- data.frame(cellNos = seq(1:ncell(s1)))
vals <- as.data.frame(getValues(s1))
tempD<- cbind(tempD, vals)
tempD <- tempD[complete.cases(tempD), ]
cellNos <- c(tempD$cellNos)
gXY <- data.frame(xyFromCell(s1, cellNos, spatial = FALSE))
tempD<- cbind(gXY, tempD)
str(tempD)
#rasterise again
s1<- stack()
for (i in 3:ncol(tempD)){
r1<- rasterFromXYZ(tempD[,c(1,2,i)])
names(r1)<- names(tempD[i])
s1<- stack(s1,r1)
}
s1
#Point data (the exisitng sample point data)
dat<- read.table("HunterValley_SiteObsAll.txt", header = T,sep = ",")  # existing soil point data
#extract covariate data at points
coordinates(dat)<- ~ X +Y
DSM_data<- extract(s1,dat, sp= 1, method = "simple") #extract
DSM_data<- extract(s1,dat, sp= 1, method = "ngb") #extract
?extract
DSM_data<- ratser::extract(s1,dat, sp= 1, method = "ngb") #extract
DSM_data<- raster::extract(s1,dat, sp= 1, method = "ngb") #extract
DSM_data<- raster::extract(s1,dat, sp= 1, method = "simple") #extract
dat<- as.data.frame(DSM_data)
dat<- dat[complete.cases(dat),]
str(dat)
#remove the grid points where there is point data
tempD<- tempD[-which(tempD$cellNos %in% dat$cellNos),]
str(tempD)
## combine grid data with the observed data
str(dat)
dat.sub<- dat[,c(2,3,6:13)]
names(dat.sub)[1:2]<- c("x", "y")
tempD.new<- rbind(dat.sub, tempD)
tempD.new$type<- NA
tempD.new$type[1:nrow(dat.sub)]<- "orig"
tempD.new$type[(nrow(dat.sub)+1):nrow(tempD.new)]<- "possibles"
## clhs sampling with fixed obs and add an extra 100 sites
# note usage of the include parameter
names(tempD.new)
res <- clhs(tempD.new[,c(4:10)], size = nrow(dat.sub) + 100,
iter = 10000, progress = TRUE, simple = TRUE,
include = c(1:nrow(dat.sub)))
res
getwd()
saveRDS(res, file = "clhs_res.rds")
getwd()
res<- readRDS("clhs_res.rds")
res<- readRDS(file = "Z:/Dropbox/2019/rmuddles/clhs_addtion/clhs_res.rds")
res
